# SensorgnomeServer #

(C) 2019 John Brzustowski

License: GPL2 or greater.

A server for the [sensorgnome project](https://sensorgnome.org) in literate go.
This file uses the [Literate Markdown Tangle](https://github.com/driusan/lmt) technique:
code blocks marked with triple back-ticks are extracted into source files using `lmt`
and these are compiled into an executable.

## Intro ##
This server manages a growing set of networked sensorgnome receivers.

## Functions ##
- [register sensorgnomes](# register)
- manage messages from SGs (i.e. store and/or forward)
- provide SG status to clients
- manage sync of SGs to motus.org (i.e. download and process raw data)
- manage remote access to SGs (i.e. let users interact directly with an SG)



- allow sensorgnomes from trusted IP addresses to self-register

sensorgnomes and stores them in a database.  It also allows sensorgnomes to register.

### Message Channels ###

Messages arrive on these channels:

- signed datagrams sent to a public UDP port.
   - the signature proves the message originated from a specified sensorgnome
   - the SG uses its server-issued public/private key pair

- unsigned datagrams sent to a local unix domain port; the datagrams are generated by a thin client
  executed by the SG over ssh (i.e. netcat.openbsd -U UDPORT)

- the factory ssh keys used by SGs to login before registering connect to a
  local unix domain port dedicated to registration
  Protocol:
    SG>  SERNO (12 chars followed by newline)
    SRV> FAILED (if serial number not valid)
    SRV> PORT\nPUBKEY\nPRIVKEY (if serial number valid and not registered before)

  - this requires a line like this in `.ssh/authorized_keys:`
  `command="/bin/nc.openbsd -U /tmp/test",from="24.224.155.*" ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFmQjHQHzz7YgJBwvU2kv1eOxqo2mfPa4Xg3NNxdz9LV test`

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type File string
type CodeBlock string
type BlockName string

var blocks map[BlockName]CodeBlock
var files map[File]CodeBlock
var namedBlockRe *regexp.Regexp
var fileBlockRe *regexp.Regexp
var replaceRe *regexp.Regexp

// Updates the blocks and files map for the markdown read from r.
func ProcessFile(r io.Reader) error {
	scanner := bufio.NewReader(r)
require (io)
        a=io.
